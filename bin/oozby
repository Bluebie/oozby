#!/usr/bin/env ruby
require 'thor'
require 'listen'
require 'pp'
require 'rbconfig'
require File.join(__dir__, '..', 'lib', 'oozby')

# motivational exit messages!
$quit_message = {
  '0.3.0' => "Have a nice day!",
  '0.3.1' => "You're a superstar!",
  '0.3.2' => "Keep up the great work!",
  '0.3.3' => "Nice job!",
  '0.3.4' => "It was a pleasure working with you!"
}

class OozbyUtility < Thor
  desc "compile some#{File::SEPARATOR}folder", "The Oozby Utility searches a directory and compiles all the .oozby files it finds, creating identically named files with .scad stuck on the end, translated in to OpenSCAD nonsense. Open those files in OpenSCAD app and enable Automatic Reload and Compile in the Design menu, then get to work."
  
  option :verbose, type: :boolean, desc: "Output lots of gunk, to figure out bizarre bugs in Oozby"
  option :abstract_tree, type: :boolean, desc: "Output Abstract Tree (debugging)"
  option :all, type: :boolean, desc: "Don't skip any files - recompile them all!"
  option :no_watch, type: :boolean, desc: "Don't watch directory for changes - exit immediately"
  def compile path
    if File.file? path
      ooz = Oozby.new
      ooz.filter_errors = !options[:verbose]
      ooz.debug = options[:verbose]
      
      begin
        ooz.parse_file path
      
        if options[:abstract_tree]
          puts "Oozby Abstract Syntax Tree:"
          pp ooz.abstract_tree
        end
      
        File.open(path + '.scad', 'w') do |handle|
          handle.write ooz.render
        end
        
        puts "compiled #{File.basename(path)}"
      rescue StandardError, ScriptError, NoMethodError => err
        local_pwd = Dir.pwd
        puts "#{err.class.name}: #{err.message.sub(local_pwd + File::SEPARATOR, '')}"
        err.backtrace.each { |line| puts line.sub(local_pwd + File::SEPARATOR, '') }
        puts nil, nil
      end
      
    elsif File.directory? path
      directory = File.absolute_path(path) # calculate real absolute path - follow any links
      globber = File.join(directory, '**', '*.oozby')
      files = Dir.glob(globber)
      files.each do |filename|
        subprocess_compile filename if !File.exists?("#{filename}.scad") || File.mtime(filename) >= File.mtime("#{filename}.scad") || options[:all]
      end
      
      unless options[:no_watch]
        recompile_handler = lambda do |*args|
          subprocess_compile File.join(*args)
        end
        
        puts "Watching folder for changes... (CTRL+C to exit)"
        Listen.to! directory, filter: /\.oozby$/ do |modified, added, removed|
          modified.each { |path| recompile_handler[path] }
          added.each { |path| recompile_handler[path] }
          removed.each do |path|
            puts "#{File.basename(path)} deleted."
            if File.exists? "#{path}.scad"
              File.delete("#{path}.scad")
              puts "Deleted generated .scad file for obsolete #{File.basename(path)}"
            end
          end
        end
      end
    end
  rescue Interrupt => e
    puts ""
    puts $quit_message[Oozby.version] || $quit_message.values.last
  end
  
  private
  # open up a subprocess to execute this file, so we don't polute the scope when watching
  # or processing several files
  def subprocess_compile filename
    this_file = File.expand_path(__FILE__)
    ruby_bin = File.join(RbConfig::CONFIG['bindir'], RbConfig::CONFIG['ruby_install_name'])
    args = [ruby_bin, this_file, 'compile']
    args.push '--verbose' if options[:verbose]
    args.push filename
    system(*args)
  end
end

OozbyUtility.start(ARGV)

